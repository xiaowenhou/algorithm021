学习笔记

1. **写一个关于 HashMap 的小总结。**

   HashMap是Java工程师实际工作中最常用的数据结构之一, 用于保存键-值对形式的数据.

   常用的api有get(根据key获取一个元素的值), put(插入一个元素), containsKey(某个元素是否存在) , 以及HashMap的遍历等.

   

   **实现方式:** 一个Node类型的数组作为散列表保存数据, 当发生hash冲突时采用拉链法处理冲突, 使用链表来保存冲突的元素, 但是当冲突的元素个数达到一定的阈值之后(默认为8), 会将链表转化成红黑树.

   ​		这种作法的好处是当冲突元素数量比较少时,  遍历链表不影响查询性能,而且链表的插入操作是O(1), 所以兼顾了插入和删除;而当冲突元素数量比较多, 链表O(n)的时间复杂度会让查询操作比较耗时, 因此转化成红黑树, 提高查询性能. 

   

   **get(key)流程:** 

   ​	先根据key计算hash值, 根据hash值找到散列表中的元素, 如果找不到, 返回空, 找到了则继续判断;

   ​	如果散列表中的第一个元素的key和查询的key相同, 说明没有发生hash冲突, 直接返回第一个元素, 否则说明发生hash冲突;

   ​	发生hash冲突时有两种情况, 一种是保存冲突的元素依然是链表, 则遍历链表, 直到找到对应的值或返回null; 另一种是保存冲突的元素是红黑树, 则遍历红黑树, 查找对应的元素或者返回null

   

   **put(key, value)流程:**

   ​	先查看散列表是否为空, 如果散列表为空, 初始化散列表.

   ​	计算key的hash值, 看散列表中对应位置是否有元素, 如果没有, 说明没有发生hash冲突, 创建一个Node对象, 保存key和value的值, 返回

   ​	如果散列表对应的位置已经存在元素, 则说明发生hash冲突

   ​	此时如果Node还是链表, 则遍历链表, 将新节点插入到链表的末尾, 同时记录链表的长度, 链表长度超过阈值(8个节点), 则调用转换函数, 将链表转换成红黑树;

   ​	如果已经是红黑树, 则在红黑树上新增一个节点.

   ​	最后, 当插入完成之后, 整个map的size加一, 然后判断当前size数是否已经超过扩容阈值, 如果已经超过, 则调用resize()方法扩容, 扩容以后会重新计算所有元素的hash值, 将元素进行重排列.

   

   **几个关键的常量参数:**

   ​	DEFAULT_INITIAL_CAPACITY: 默认初始大小, 16. 创建HashMap的时候如果不指定大小, 则为16

   ​	DEFAULT_LOAD_FACTOR: 默认加载因子, 为0.75, 即当已用容量超过全部容量的3/4之后, 准备扩容

   ​	TREEIFY_THRESHOLD: 值为8. 发生hash冲突采用拉链法, 当链表中的节点的值大于该值之后, 链表会转化为树

   ​	UNTREEIFY_THRESHOLD: 值为6. 当冲突的节点数小于该值时, 树会再转化为链表.

   ​	

   **为什么HashMap的容量大小必须是2的整数次幂?**

   ​	HashMap扩容时是扩容成原来的两倍, 并且要求是2的整数次幂, 如果在创建时指定的容量不为2的整数次幂, 在创建时也会调整成大于该值的最小2的整数次幂

   ​	这样做的目的是计算key的hash值后, 能够快速找到该hash值对应在散列表上的位置. 具体做法是容量减一, 然后与hash值按位与, 由于容量是2的整数次幂, 减一之后就会得到全为1的二进制码(如'11111111'), 然后与hash值按位与就能快速得到散列表的下标, 计算过程采用减法操作和位运算, cpu的计算效率最高

   

2. **树的面试题解法一般都是递归，为什么？**

   是由递归算法的要点和树的数据结构决定的.

   使用递归的四个要点:

   ​	一是要有明确的退出条件

   ​	二是要找到最小重复性

   ​	三是处理当前逻辑

   ​	四是返回值

   再来看树这种数据结构的特点:

   ​	第一,  叶子节点没有子节点的特点正好符合递归的第一个条件, 当递归到叶子节点时, 递归就可以结束了.

   ​	第二, 树的中间节点都既是上一层的子节点, 又是下一层的根节点, 这种重复性正好符合递归的第二个条件, 对树的处理基本都可以简化为父节点和子节点的处理, 这就是树的最小重复性.

   ​	由这两点, 就可以发现树非常适合用递归解决问题.