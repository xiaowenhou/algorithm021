学习笔记

1. **写一个关于 HashMap 的小总结。**

   HashMap是Java工程师实际工作中最常用的数据结构之一, 用于保存键-值对形式的数据.

   常用的api有get(根据key获取一个元素的值), put(插入一个元素), containsKey(某个元素是否存在) , 以及HashMap的遍历等.

   

   **实现方式:** 一个Node类型的数组作为散列表保存数据, 当发生hash冲突时采用拉链法处理冲突, 使用链表来保存冲突的元素, 但是当冲突的元素个数达到一定的阈值之后(默认为8), 会将链表转化成红黑树.

   ​		这种作法的好处是当冲突元素数量比较少时,  遍历链表不影响查询性能,而且链表的插入操作是O(1), 所以兼顾了插入和删除;而当冲突元素数量比较多, 链表O(n)的时间复杂度会让查询操作比较耗时, 因此转化成红黑树, 提高查询性能. 

   

   **get(key)流程:** 

   ​	先根据key计算hash值, 根据hash值找到散列表中的元素, 如果找不到, 返回空, 找到了则继续判断;

   ​	如果散列表中的第一个元素的key和查询的key相同, 说明没有发生hash冲突, 直接返回第一个元素, 否则说明发生hash冲突;

   ​	发生hash冲突时有两种情况, 一种是保存冲突的元素依然是链表, 则遍历链表, 直到找到对应的值或返回null; 另一种是保存冲突的元素是红黑树, 则遍历红黑树, 查找对应的元素或者返回null

   

   **put(key, value)流程:**

   ​	先查看散列表是否为空, 如果散列表为空, 初始化散列表.

   ​	计算key的hash值, 看散列表中对应位置是否有元素, 如果没有, 说明没有发生hash冲突, 创建一个Node对象, 保存key和value的值, 返回

   ​	如果散列表对应的位置已经存在元素, 则说明发生hash冲突

   ​	此时如果Node还是链表, 则遍历链表, 将新节点插入到链表的末尾, 同时记录链表的长度, 链表长度超过阈值(8个节点), 则调用转换函数, 将链表转换成红黑树;

   ​	如果已经是红黑树, 则在红黑树上新增一个节点.

   ​	最后, 当插入完成之后, 整个map的size加一, 然后判断当前size数是否已经超过扩容阈值, 如果已经超过, 则调用resize()方法扩容, 扩容以后会重新计算所有元素的hash值, 将元素进行重排列.

   

   **几个关键的常量参数:**

   ​	DEFAULT_INITIAL_CAPACITY: 默认初始大小, 16. 创建HashMap的时候如果不指定大小, 则为16

   ​	DEFAULT_LOAD_FACTOR: 默认加载因子, 为0.75, 即当已用容量超过全部容量的3/4之后, 准备扩容

   ​	TREEIFY_THRESHOLD: 值为8. 发生hash冲突采用拉链法, 当链表中的节点的值大于该值之后, 链表会转化为树

   ​	UNTREEIFY_THRESHOLD: 值为6. 当冲突的节点数小于该值时, 树会再转化为链表.

   ​	

   **为什么HashMap的容量大小必须是2的整数次幂?**

   ​	HashMap扩容时是扩容成原来的两倍, 并且要求是2的整数次幂, 如果在创建时指定的容量不为2的整数次幂, 在创建时也会调整成大于该值的最小2的整数次幂

   ​	这样做的目的是计算key的hash值后, 能够快速找到该hash值对应在散列表上的位置. 具体做法是容量减一, 然后与hash值按位与, 由于容量是2的整数次幂, 减一之后就会得到全为1的二进制码(如'11111111'), 然后与hash值按位与就能快速得到散列表的下标, 计算过程采用减法操作和位运算, cpu的计算效率最高

   

2. **树的面试题解法一般都是递归，为什么？**

   是由递归算法的要点和树的数据结构决定的.

   使用递归的四个要点:

   ​	一是要有明确的退出条件

   ​	二是要找到最小重复性

   ​	三是处理当前逻辑

   ​	四是返回值

   再来看树这种数据结构的特点:

   ​	第一,  叶子节点没有子节点的特点正好符合递归的第一个条件, 当递归到叶子节点时, 递归就可以结束了.

   ​	第二, 树的中间节点都既是上一层的子节点, 又是下一层的根节点, 这种重复性正好符合递归的第二个条件, 对树的处理基本都可以简化为父节点和子节点的处理, 这就是树的最小重复性.

   ​	由这两点, 就可以发现树非常适合用递归解决问题.

   **3.一周总结**

   本周主要学习了三个数据结构, Hash表, 树, 图.

   ​	**Hash表:** 是一个一维的数据结构, 用一个数组存储数据, 当要存储元素时, 先计算该元素的hash值, 然后根据hash值确定该元素放在数组的哪个位置, 因此其查询, 插入, 删除的时间复杂度都可以认为是O(1). 但是也有例外,即当多个元素计算出来的hash值相同时, 就产生了hash冲突, 此时一般的解决方案是在数组的每个元素后面再挂一个链表, 当有hash冲突时就向链表的尾部插入元素, 因此, hash函数就至关重要, 好的hash函数能够大大减小冲突的概率.

   ​	Java 8中Hash结构的类是HashMap, 其实现与上述类似, 但是不同点在于存储因hash冲突的元素时除了使用链表, 还用了红黑树这种数据结构, 当hash冲突的元素数量超过阈值(8个)时, 链表就会转化为红黑树以获取更高的性能. 此外, 当HashMap中的元素超过HashMap容量的3/4时就会进行扩容, 扩容后会重新计算hash值放置元素, 是一个比较耗费性能的操作, 因此使用HashMap时, 尽可能估算出要存储的键值对的数量, 在创建时就确定好, 避免频繁扩容

   ​	**树**: 一种二维的数据结构, 有根节点, 叶子节点, 父节点, 孩子节点以及层数等概念, 树是泛化的链表. 

   ​		二叉树: 树中任何一个节点都最多只有两个子节点. 

   ​			二叉树遍历: 前序: 根 -> 左 -> 右; 中序: 左 -> 根 -> 右; 后序: 左 -> 右 -> 根, 时间复杂度均为O(n), 因为是将所有的节点访问一次.

   ​		二叉搜索树: 一颗二叉树, 满足其左子树上的所有节点都小于根节点, 其右子树上的所有节点都大于根节点. 对树做中序遍历得到的就是有序的.

   ​			一般情况下, 二叉搜索树的查询, 插入, 删除都是O(logn)的时间复杂度, 但是在极端情况下, 有可能退化成为链表, 此时查询就是O(n)的时间复杂度. 为了解决这个问题, 后来又出现了二叉平衡树.

   ​		由于树的特性, 因此常用递归来解决和树有关的问题.

   ​	**堆:** 一种抽象的数据结构, 是指能够以O(1)的时间复杂度获取到堆中最大/最小的元素, 其实现方式有多种, 面试中常考的是由二叉树实现的堆, 获取最大/最小元素为O(1), 删除最大元素为O(logn), 插入元素为O(logn); 工程中使用的是由其他更加复杂的方式实现的堆, 如斐波那契堆, 严格的斐波那契堆, 其获取最大/最小元素为O(1), 删除最大元素为O(1), 插入元素为O(1).

   ​		二叉堆的定义: 以大顶堆为例, 一个完全二叉树, 其左右孩子的值均小于其父节点, 这样根节点就是整个堆中最大的元素.

   ​			代码实现: 由于二叉堆的特性, 因此可以用一个数组来表示二叉堆, 元素按照根, 左, 右的顺序依次放入在数组中, 对于一个下标为i的元素, 其左右孩子的下标分为为(2i+1)和(2i+2), 其父亲节点的下标为floor((i-1)/2).

   ​			获取最大值: 返回根节点的值, 即array[0], 

   ​			插入元素: 先将元素插入到后面, 然后向上浮动, 即不断的和其父亲节点比较, 如果比父亲节点大, 就和父亲节点交换, 直到其小于父亲节点或者成为根节点为止. 交换的次数就是树的层数, 因此为O(logn)

   ​			删除最大的元素: 将根节点和最后一个节点进行互换, 然后删掉最后一个节点, 然后再把根节点向下沉, 直到其下沉到最底部为止.交换的次数就是数的层数, 因此为O(logn).

   ​	**图**: 图是泛化的树, 即树中出现了环. 图的概念有点, 边, 权重,根据边是否有朝向分为有向图和无向图, 根据边是否有权重分为有权图和无权图.

   ​		图一般用二维矩阵或者相邻表表示.

   ​			二维方阵: 行和列都表示点, 行与列的交叉处表示点到点之间的关系, 边的默认权重为1, 如果两点之间无关系, 则交叉点为0, 有关系则交叉点为1或权重值, 此外, 将二维方阵的左对角线分开, 上下两部分分别表示边的方向.

   ​			相邻表: 用一个数组表示图中所有的点, 每个数组元素又指向一个链表, 用该链表中的元素表示和该点有连接的点

   ​		图在面试中考的较少, 主要需要掌握图的广度优先遍历(DFS)和图的深度优先遍历(BFS)