学习笔记

**一、知识点**

​	**算法和数据结构通识：**

​		时间复杂度：程序计算的次数和数据规模之间的数量级关系。一般用于衡量算法的优劣，算法时间复杂度越少越好。主要有O(1),O(logn),O(n),O(nlogn),O(n^2),O(n^3),O(2^n),O(n!)几种。

​			计算方式： 一般程序，计算程序循环的次数；递归程序，计算需要多少次的递归，一般程序中只调用一次递归函数， 则是O(n)， 如果是调用k次， 则是O（k^n）次方， 具体计算可以通过画状态数实现。

​		空间复杂度：程序执行时所占用内存的空间大小。同样用于衡量算法的优劣，重要性不如时间复杂度，相同时间复杂度下， 空间复杂度越小越好。计算时一般主要看数组的长度和进行递归的深度。

​	**数据结构：**

​		**一维的数据结构：**

​			**数组：**元素连续排列，随机查询O(1),头尾插入O(1),随机插入O(n),常见解法， 暴力破解、双指针。

​			**链表：**元素随机排列， 元素和元素之间通过指针定位。随机查询O(n), 头尾查询O(1), 随机插入O(1)。常见解法，循环， 递归，解法简单， 但是要多写多练。

​			**队列：**先进先出的一维数据结构，查询O(n),入队出队均为O(1)，常用于解决窗口问题。

​			**栈：**后进先出的一维数据结构，查询O(n), 入栈出栈均为O(1)，常用于解决最小相似性的问题。

​			**散列表（Hash）：**数组存储元素，先计算插入元素的hash值， 然后根据hash值查找数组中的位置放入元素，如果出现hash冲突，用链表法或者寻址法解决。查询，插入，删除都可以近似认为是O(1)的时间复杂度。在数组类的题目中常用于缓存达到优化时间复杂度的目的。

​			**集合（Set）：**一个元素都不重复的集合，底层就是一个hashmap，但是没有值，查询，插入，删除都可以认为是O(1). 在题目中常用于去重，缓存以达到优化时间复杂度的目的。

​			**跳表（SkipList）**：t通过提升维度以存储额外的信息来达到优化的目的，前提条件是节点必须有序。实现是在链表 的基础上创建几层索引，索引节点既指向下一层， 又指向同层的下一个节点，查询时从最上一级索引开始查找，然后再一层一层向下查询，每一层都会跳过一些元素。随机查询、插入都是O(logn)的时间复杂度。



​		**二维的数据结构：**

​			**树**：节点， 层数，根节点， 叶子节点， 左子树， 右子树，常用解题方式有递归，DFS， BFS。常见的操作有遍历，分为前序（根左右）， 中序（左根右）， 后序（左右根）三种， 都可以用递归、DFS以及BFS的方式实现。DFS和递归都是使用了一个栈， 只不过递归是由系统维护，DFS需要手动维护， BFS则是使用了一个队列存储中间每一层的节点。

​				**二叉树**：一个树最多只有两个子树。

​					**二叉搜索树：**二叉树中每一个节点的左子树都小于根节点， 右子树都大于根节点， 且每一个节点单看也是二叉搜索树。其中序遍历即将树中的节点按照从小到大遍历。查询，插入， 删除均为O(logn)，但是极端情况下会退化位链表， 查询O(n)

​					**二叉平衡搜索树：**为杜绝二叉搜索树最差情况的出现， 当树的单边层级大于2时，会进行动态平衡，保证二叉树的平衡。具体实现红黑树和AVL。

​				**多叉树**：树中的每一个节点右多个子树

​					**并查集：**

​					**字典树（Trie）：**用于单词的快速前缀搜索。节点中不存储完整的单词，从根节点到叶子节点的路径组合起来就形成一个完整的单词，且从根节点到叶子节点的路径组合起来的每个单词都不重复。

​					**B树：**多叉树，每个节点中保存多个数据，节点中的数据按照顺序排列，每个数据都有指针指向下一层，解决了二叉平衡搜索树层级太高的问题，但是存在范围查询时从中间节点到叶子节点之间来回反复的问题。

​					**B+树：**在B树的基础上增加以下额外限制，B+树中间节点不保存数据，所有数据都保存在叶子节点，叶子节点通过双向链表连通。解决了B树范围查询的问题，查询时先定位边界， 然后直接将边界包含的叶子节点返回即可。是数据库系统中使用的索引结构。

​				**堆**：用于快速获取一组元素中的最大/最小值，面试中常考的是二叉堆，获取最大/小值O(1), 插入O(logn), 删除最大值O(logn)，工业级实现中用其他更复杂的实现方式达到更优的性能。二叉堆可以通过一个数组实现，常用的题目有topK的问题。

​			**图：**有点右边的二维数据结构，和树的区别在于图中的节点有闭环， 分为无向无权图， 有向无权图， 无向有权图， 有向有权图。可以通过二维数组或者数组+链表实现一个图

​		**其他数据结构：**

​			**位运算：** 布隆过滤器，用于挡在数据系统最前方过滤系统中不存在的元素，特点是速度快，查询是O(1)的复杂度，占用内存小，使用了二进制bit位，但结果是非精确的，即布隆过滤器认为不存在的数据则一定不存在， 但是布隆过滤器认为存在的数据则不一定存在。

​			**LRU缓存：** 最近最少使用策略，常用于缓存失效后的替换。采用HashMap和双向链表实现。插入，查询的时间复杂度都为O(1)。

​	**算法：**

​		**基本算法：** 

​			**分支：**if-else

​			**循环：**for ， while， do...while

​			**递归：**向下去到下一层，向上回到上一层。层与层之间通过函数的参数或者全局变量传递数据或者状态，每一层都相对独立。代码结构分四部分，一是定义退出条件， 二是当前层的逻辑，三是下传到下一层， 四是清除当前层的执行结果。

​		**高级算法：**

​			**分治：**本质还是递归，将一个大的问题分而治之为子问题，然后再将子问题进行分解，直到问题解决或无法再分解。代码结构分为五部分，一是定义退出条件，一般为问题解决或者无法再分割子问题； 二是当前层的逻辑，就是分解子问题， 三是下传到下一层， 四是将子问题进行合并， 五是清除当前层的结果

​			**回溯：**本质还是递归，在递归的每一层中寻找可能的解， 如果找到， 则求解， 如果不满足条件， 则在上一层中清除状态， 再继续向下找，就像时光倒流重头再来一样。

​			**搜索：**

​				**深度优先DFS：**先对一路一竿子捅到底， 然后再上来搜另一路,时间复杂度O(n)

​				**广度优先BFS：**一层一层的搜索，类似水波纹的扩散出去,时间复杂度O(n)

​				**启发搜索A*：**每一次搜索都选择最优的， 然后再通过最优的继续搜索。

​			**二分查找：**数组有序，通过每次比较排除一半的元素，时间复杂度为O(logn)

​			**排序：**

​					**基本排序：**冒泡，选择， 插入，都是O(n^2)的时间复杂度

​					**高级排序：**快速排序，归并排序，堆排序，希尔排序，都是O(nlogn)的时间复杂度

​			**贪心：**在每一个步骤中都选择当前最优的解法， 最终的结果就是最优的，关键在于要从逻辑上证明确实能够通过贪心得到问题的解。

​			**动态规划：**如果一个问题存在最优子结构，那么就可以用动态规划来解决。动态规划主要有三步， 一是寻找最优子结构， 二是定义状态集合， 三是定义状态方程。难点在于找到状态集合以及定义状态方程，需要多多练习。

**二、刷题方法**

​	**五毒神掌：即一道题目至少练习五遍以上，平时多刷老题，最大的误区就是题目只用做一遍**

​		第一遍：阅读完题目之后， 如果有思路， 则直接开始动手写代码调试，如果没有思路， 思考十到十五分钟后， 直接看题解，学习别人的思路和解法， 然后临摹代码

​		第二遍：第一遍之后，不看题解，凭借自己的记忆和理解写出代码

​		第三遍：第二遍刷完24小时之后，不看题解， 直接写出代码

​		第四遍：第三遍刷完7天后， 不看题解， 直接写出代码（感觉这一遍最痛苦，经常需要苦苦思索）

​		第五遍：面试前再刷一遍， 加深印象

​		每一遍刷完之后， 还要到leetcode国际站上面看一下国际站中的本语言实现的高票回答， 学习别人的简洁代码和精妙思路。

​	五毒神掌这个方法其实可以应用到任何领域的技能学习上，本质就是通过重复和基础的工作，不断加深大脑的记忆和技能的熟练度。所谓书读百遍，其意自现也是这个道理， 平时在学习中也有这个感觉， 有的知识点， 第一次看觉得懵懵懂懂，但是过段时间再看就会有一些不一样的理解， 然后再过一段时间再看，就会觉得原本晦涩难懂的东西变得简单起来， 然后等看的多的时候， 就能够发现技术之间的相通性， 此时再去学习新的技术时就会比较快了。

**三、面试时的切题步骤**

​	**切题四件套：面试时应对编程题的一个完整的流程**

​	首先，阅读题目， 针对其中的边界条件等和面试官进行沟通确认

​	其次，描述能想到的所有解法，选择自己认为最好的一种解法， 并阐述为什么选择这个解法

​	再次，编写代码实现

​	最后， 给出几个测试用例， 包括正常情况的测试用例和特殊情况的测试用例

​	切题四件套也同样可以应用到工作中， 工作中上级交待自己一个任务，或者遇到一个问题， 首先就是和上级进行沟通， 针对可以用的资源、条件、做事的背景、最终要求的结果、时间节点进行沟通澄清；然后思考所有可以解决问题的方案， 最终选择一个认为最好的方案出来， 这期间可能还要反复和上级以及其他同事进行沟通；接着就是动手实现；最后，根据结果向上级反馈。